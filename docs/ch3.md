> 책의 내용을 그대로 옮기기보단 저만의 언어 위주로 정리해 보았습니다.

# 3. 1. 아키텍트 이야기 : 마이크로서비스 아키텍처 설계

## 아키텍트의 역할

### 비즈니스 문제 분해

- 해결해야 할 문제를 필수적인 부분으로 분해
- 나눠진 부분 사이의 관계를 찾으려고 함
- 비즈니스 문제를 각 영역을 대표하는 덩어리(Object)로 분해하고 비즈니스 영역의 특정 부분과 연관된 규칙과 로직(Method)을 덩어리 안에 은닉
- 비즈니스 영역 분해는 과학보단 어쩌면 예술의 영역
- 분해 지침으로는 다음을 참고할 수 있음
  - 비즈니스 문제 기술에 사용된 명사에 주목
    - 도메인 객체의 이름
  - 동사에 주목
    - 조회하다
    - 업데이트하다
  - 데이터 응집성 찾기
    - 고려한 것과 다른 데이터를 읽거나 쓴다면 새로운 서비스 후보가 나타난 것일 수 있음
    - 마이크로서비스는 온전히 자신의 데이터를 가져야 함

### 서비스 세분화 확정

- 주요 기능 부분을 서로 독립적으로 빌드하고 배포할 수 있는 완전한 자립형 유닛으로 추출해야 함
- 예제는 기존 레거시 애플리케이션이 있는 것으로 가정하기 때문에, 먼저 모놀리스 애플리케이션을 세분화하는 것으로 시작함
- 따라서 데이터베이스를 공유할 수 있으나 문제 영역을 개별 조각으로 나누 후 서비스에 대해 적절한 수준의 세분화를 하는 것을 목표로 함
- 이 적절한 수준의 세분화라는 것을 찾아내기 위해 다음의 개념을 적용할 수 있음
  - 마이크로서비스는 광범위하게 시작하고 추후 더 작은 서비스로 리팩터링하는 것이 좋다
    - 처음에 마이크로서비스를 구축하다 보면 모든 것을 마이크로서비스로 만들어 버릴 수 있음
    - 이렇게 되면 각 마이크로서비스가 단순 CRUD 작업을 하는 서비스가 될 수 있음
    - 이 경우 조기에 높은 복잡성을 경험할 수 있음
    - 따라서 처음에는 조금 더 범용적인 서비스를 개발하고, 추후에 단위가 커지는 것 같을 때 작은 서비스로 리팩터링 하는 것이 좋음
  - 어떻게 서비스들끼리 서로 상호작용할지에 대해 먼저 집중하는 것이 좋다 (원서 직접 번역)
    - 도메인 영역 간 교류를 위한 인터페이스를 만드는데 도움이 됨
    - 이렇게 생각하다 보면 너무 잘게 나눠진 서비스를 처음부터 설계하는 것보다, 그래도 굵게 나눠진 서비스들을 잘게 나눠진 서비스로 리팩터링해나가는 방향이 더 쉽다고 생각하게 됨
  - 문제 도메인에 대한 이해가 깊어지면서 서비스의 책임도 계속 변한다
    - 새로운 애플리케이션 기능이 요구될 때 대개 특정 마이크로서비스가 그 책임을 맡음
    - 마이크로서비스는 처음엔 단일 서비스로 시작하여 여러 서비스로 분화하며 성장하는데, 기존의 서비스는 이 새로운 서비스들을 오케스트레이션하고 애플리케이션의 다른 부분 기능을 캡슐화하는 역할을 함
      - 예를 들어 보면, 모놀리식 애플리케이션을 마이크로서비스로 리팩터링하다보면 결국 API Gateway, 그 뒤에 BFF, 그 뒤에 마이크로서비스의 형태를 갖추게 될 수 있음
      - API Gateway와 BFF가 기존의 서비스 서버이고, 마이크로서비스가 분화되어 나간 서비스 서버일 가능성이 높음
- 나쁜 마이크로 서비스의 징후는 다음과 같이 생각할 수 있음
  - 책임이 너무 많은 서비스
    - 비즈니스 로직의 일반적인 흐름이 복잡하고 지나치게 다양한 종류의 비즈니스 규칙을 시행하는 것처럼 보일 때
      - 솔직히 이 기준은 개인마다 다 다를 것이라 팀 내부의 컨센서스가 중요할 것 같음
  - 다수 테이블에 걸쳐 데이터를 관리하는 서비스
    - 번역이 다소 이상함 (마이크로서비스는 자기가 관리하는 데이터에 대한 기록이다?...)
    - A microservice is the system of record for the data it manages -> 한 마이크로서비스는 그것이 관리하는 데이터에 대한 레코드에 관한 시스템임
    - 만약 여러 테이블에 데이터를 관리하거나 현재 접근중인 (논리) 데이터베이스 외부의 테이블에 접근한다면 서비스가 너무 크다는 징조가 될 수 있다.
    - 필자는 마이크로서비스가 3~5개 이하의 테이블을 소유해야 한다는 지침을 사용하고 싶다고 함
    - 이보다 더 많으면 서비스가 과중한 책임을 담당할 수 있음
  - 테스트가 너무 많은 서비스
    - 서비스는 시간이 지남에 따라 규모와 책임이 커질 수 있음
    - 적은 수의 테스트 케이스로 시작했는데, 너무 많은 수의 유닛 테스트와 통합 테스트를 보유하게 된다면 서비스를 분리하는 리팩터링이 필요할 수 있음
      - 많은 수의 테스트가 특정 서비스에 복잡한 책임이 엮여있을 수 있다는 징조라는 의미인 듯
- 서비스를 너무 작게 나누어도 다음의 문제를 가질 수 있음

  - 문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다
    - 피보나치 수열을 따른다는 것인데 꽤 매력적인 비유인 것 같음
    - 모든 것을 너무 작은 마이크로서비스로 나눠버리면 비즈니스 로직을 구성하는 것이 복잡하로 어려워짐
    - 작업을 완료하기 위해 필요한 서비스의 수가 너무 많아지기 때문
    - 애플리케이션에 수많은 서비스가 존재하고, 각 서비스는 단 하나의 테이블과 통신할 때는 문제가 있는 형태일 수 있음
  - 마이크로서비스가 지나치게 상호 의존적임
    - 비즈니스 문제 영역의 한 부분에 속한 마이크로서비스가 하나의 사용자 요청을 완료하려고 서로 수많은 호출을 하고 있음을 발견하게 됨
  - 마이크로서비스가 단순한 CRUD 서비스 집합이 된다
    - 마이크로서비스의 서비스 레이어가 CRUD만 하고 있다면 너무 과하게 세분화된 것일 수 있음

- 마이크로서비스는 처음부터 올바른 설계를 얻기 어렵기 때문에 진화적인 사고 프로세스(점진적으로 나아지도록 하는 사고 프로세스)를 가지고 개발되어야 함
- 이것이 처음에는 서비스들을 조금 더 크게 나눠서 시작해야 하는 이유
- 독단적 설계를 하지 않는것도 중요함
  - 서비스에 물리적 제약이 있을 수 있음
    - 예를 들어 두 개별 서비스 사이에 너무 많은 호출이 발생하거나 서비스 간 도메인 경계가 명확하지 않으면 데이터를 조인하는 집계 서비스를 만들어야 함
- 완벽한 설계를 얻고 싶어 시간을 낭비하고 노력에 비해 아무것도 보여주지 못하는 것보다 실용적 접근 방식을 취해 설계를 전달하자

### 서비스 인터페이스 설계

- 일반적으로 서비스 인터페이스 설계에 대해 다음 지침을 활용할 수 있음
  - REST 철학 고수하기
    - 리처드슨의 모범 사례 중 하나임
    - HTTP 동사 기반으로 기본 행동 양식 모델링하기
  - URI를 사용하여 의도를 전달하기
    - 서비스의 엔드포인트로 사용되는 URI는 문제 영역에 존재하는 다양한 자원을 기술해야 함
    - 자원 관계에 대한 기본 메커니즘을 제공해야 함
  - 요청과 응답에 JSON 사용하기
    - 책이 써질 때에는 아직도 XML을 많이 사용했었나 봄
    - XML 보다 JSON 을 사용하라는 것
  - HTTP 상태 코드로 결과를 전달하라
    - HTTP 프로토콜에 있는 풍부한 표준 응답 코드를 사용할 것
    - 응답 코드를 일관되게 사용하는 것은 매우 중요함
- 전반적으로 gRPC나 Protobuf 가 없던 시절에 써진 책이라는 강한 냄새가 남

# 3.2. 마이크로서비스를 사용하지 말아야 할 때

## 분산 시스템 구축의 복잡성

- 마이크로서비스는 분산되고 세분화되어 있음
  - 이로부터 모놀리식 애플리케이션에서 없던 복잡성이 발생함
- 마이크로서비스 아키텍처에서는 높은 운영 성숙도가 필요함
- 조직에서 고도로 분산된 애플리케이션을 성공시키는데 필요한 자동화와 운영 작업(모니터링, 확장 등)에 기꺼이 투자하지 않는 한 마이크로서비스 사용을 고려하지 않는 편이 좋음
  - 사실상 첫 프로덕트에서는 사용하기 적합하지 않음
  - 꽤 큰 규모의 기업이 아니라면... 굳이...

## 서버 또는 컨테이너 스프롤

- 스프롤 : 도시계획과 관리 등이 불량하여 발생하는 현상
- 대규모 마이크로서비스 기반 애플리케이션을 서버에 띄우고, 관리하고, 모니터링하고, 운영하는 작업은 엄청나게 복잡할 수 있다. (감사합니다, 감사합니다)

## 애플리케이션의 종류

- 작거나 부서에서 사용하기 위한 정도의, 혹은 작은 유저 베이스를 가진 애플리케이션을 만들 때 마이크로서비스를 채택하면 앞서 말한 대로 분산 환경을 운영하기 위한 높은 수준의 자동화, 운영 비용이 발생할 수 있다.
- 대규모 애플리케이션이라면 마이크로서비스를 활용하는 것이 매우 유용하다.

## 데이터 트랜잭션과 일관성

- 우리의 서비스와 유저의 데이터 사용 패턴을 충분히 생각해야 함
- 마이크로서비스는 적은 수의 테이블을 추상화하고, 데이터 저장소에 단순한 쿼리, 생성, 추가, 실행 등 운영성 작업을 수행하는 메커니즘으로는 매우 잘 작동함. (문제 없이!)
- 애플리케이션이 여러 데이터소스에 걸쳐 복잡한 데이터를 집계하고 변환해야 한다면 마이크로서비스의 분산된 특성으로 이 작업이 어려워짐.
- 그 순간 당신의 마이크로서비스는 여지없이 많은 책임을 담당하게 될 것이고, 성능 이슈도 잔뜩 겪게 될 것.
- 마이크로서비스들을 넘어다니면서 트랜잭션을 수행할 때 어떠한 표준도 없음을 기억할 것
  - 만약 트랜잭션 관리가 필요하다면 이 로직을 직접 만들어야 함
  - 이 때 메시징을 활용해볼 수 있음
    - 하지만 메시징은 데이터 업데이트에 지연을 불러옴
      - 이것을 핸들링하기 위해서 결과적 일관성 (Eventual Consistency)을 관리해야 함

# 3. 3. 개발자 이야기 : 스프링 부트와 자바

- 대부분 그냥 구현 신택스 설명

# 3. 4. 데브옵스 이야기 : 혹독한 런타임 구축

- 마이크로서비스는 일체형(self-contained)이어야 함
  - 하나의 소프트웨어 산출물만 있어도 시작 / 종료할 수 있는 서비스의 여러 인스터스를 독립적으로 배포할 수 있어야 함
- 마이크로서비스는 구성 가능(configurable)해야 함
  - 서비스 인스턴스가 시작하면 필요한 구성 정보를 한 곳에서 읽어 오거나 환경 변수로 전달받아야 함
  - 서비스 구성 정보 설정하는 데 사람의 개입이 없어야 함
    - SSH로 들어가서 vim이나 emacs / nano로 application.properties 수정하는 짓 해서는 안된다는 뜻
  - 마이크로서비스 인스턴스는 클라이언트에 투명(transparent)해야 함
    - 클라이언트는 서비스의 정확한 위치를 알아서는 안됨 (안보여야 함)
    - 클라이언트가 마이크로서비스와 통신하기 위해서는 서비스 디스커버리 에이전트와 통신해야 함
  - 마이크로서비스는 자기 상태(health)를 전달해야 함
    - 마이크로서비스 인스턴스는 언제든지 고장날 수 있기 때문에, 디스커버리 에이전트에게 자신의 상태를 알려야 함

## 서비스 조립 : 마이크로서비스의 패키징과 배포

- 데브옵스 관점에서 마이크로서비스 아키텍처의 핵심 개념은 애플리케이션의 환경 변화에 대응해서 마이크로서빗의 많은 인스턴스를 신속하게 배포할 수 있다는 것
  - 갑작스런 트래픽 증가나 인프라 문제에 대처
- 이를 위해 마이크로서비스는 연관된 모든 의존성을 포함한 단일 산출물로 패키징되고 설치 가능해야 함
- 마이크로서비스를 호스팅하는 런타임 엔진도 이 의존성에 포함됨
  - HTTP 서버나 애플리케이션 컨테이너 (Tomcat, Spring Container)
- 대부분의 자바 마이크로서비스 프레임워크는 코드와 함께 패키징하고 배포할 수 있는 런타임 엔진을 포함
- 스프링 부트 예제에서 메이븐과 스프링 부트는 내장형 톰캣 엔진을 포함하여 JAR 실행 파일을 빌드
- 예전 방식 (WAS에 애플리케이션을 배포)을 사용하면 배포 과정에서 문제 발생
  - 애플리케이션의 서버의 구성 정보를 소스 제어 저장소에서 관리하지 않고 사용자 인터페이스나 자체 관리 스크립트로 관리하기 때문
  - 애플리케이션 서버 환경에서 구성 불일치가 너무 쉽게 발생, 무작위 장애를 일으키게 됨

## 서비스 부트스크래핑 : 마이크로서비스의 구성 관리

- 서비스 부트스크래핑은 마이크로서비스가 처음 시작하고 애플리케이션 구성 정보를 로드할 때 일어남
- 마이크로서비스는 대개 동일한 종류의 구성 요구
- 이러한 구성 정보에서는 단순한 key-value 저장소를 사용하여 관리하는 것이 나음

## 서비스 등록과 디스커버리 : 클라이언트가 마이크로서비스와 통신하는 방법

- 마이크로서비스 클라이언트 관점에서 위치 투명성을 가져야 함
  - 클라우드 환경에서 서버는 일시적이기 때문
    - 클라우드 서비스는 완전 새로운 IP 주소를 할당받아 신속하게 시작되고 종료될 수 있음
- 서비스 수명을 짧고 폐기 가능한 객체를 다루자는 주장 덕분에 마이크로서비스 아키텍처는 많은 서비스 인스턴스를 실행, 높은 수준의 확장성과 가용성 얻음
- 상황이 허락되는 한 신속하게 서비스 요구와 회복 탄력성 관리 가능
- 모든 서비스에는 고유하고 비영구적인 IP 주소가 할당됨
- 일시적 서비스의 단점은 끊임없이 서비스 시작과 종료를 반복하는 상황에서 대규모 서비스를 직접 핸들링하려고 할 때 장애를 초래할 수 있다는 것
- 마이크로서비스 인스턴스는 제 3자 에이전트에 자신을 등록해야 함
  - 이 등록 과정을 서비스 디스커버리라고 함
- 마이크로서비스 인스턴스가 서비스 디스커버리 에이전트에 등록될 때 2가지 정보를 제공
  - 물리적 IP 주소 (또는 서비스 인스턴스의 도메인 주소)
  - 애플리케이션이 서비스를 찾을 때 사용되는 논리적 이름
  - 특정 서비스 디스커버리 에이전트의 경우 상태 확인(health check)을 수행할 때 사용할 호출 가능 URL도 요구
- 서비스 클라이언트는 디스커버리 에이전트와 통신하여 서비스 위치를 찾음

## 마이크로서비스의 상태 전달

- 서비스 디스커버리 에이전트는 클라이언트를 서비스 위치로 안내하는 역할만 함
- 클라우드 기반 마이크로서비스에는 하나의 애플리케이션을 위해 실행중인 서비스 인스턴스가 많음
  - 따라서 이 인스턴스 중 하나가 고장날 수 있음
- 서비스 디스커버리 에이전트는 등록된 각 서비스 인스턴스 상태를 모니터링
  - 라우팅 테이블에서 실패한 서비스 인스턴스를 제거
    - 클라이언트가 실패한 서비스 인스턴스와 통신하지 않게 해야 함
  - 이를 위해 상태 확인 인터페이스를 핑(ping)함
- 일관된 상태 확인 인터페이스를 만들어 클라우드 기반 모니털이 도구를 사용하여 문제 탐지 및 대응
- 서비스 디스커버리 에이전트가 문제 있는 서비스 인스턴스를 발견하면 고장난 인스턴스를 종료시키거나 새로운 서비스를 추가하는 등 정상화 조치 할 수 있음
- REST일 땐 JSON 응답하는 HTTP 엔드포인트 노출하는 것이 가장 쉬움
  - 스프링에서는 Spring Actuator을 포함하도록 메이븐 빌드 파일만 수정하면 됨
